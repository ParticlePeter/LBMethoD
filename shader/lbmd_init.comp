// --- COMP ---
#version 450

// Inject definition for:
//  cls(X/Y) = computeLocalSize divisions
//  div(X/Y) = divisions of the simulation grid
//  typ(X/Y) = divisions of the cell type grid (typ = div + 2)
// --- DEFINE ---

// spetialization constants for local work group size
layout( local_size_x_id = 0 ) in;
layout( local_size_y_id = 1 ) in;
layout( local_size_z_id = 2 ) in;

// local work group defaults, when constants are not defined
layout( local_size_x = 256 ) in;
layout( local_size_y =   1 ) in;
layout( local_size_z =   1 ) in;

// populations 1 single buffered rest velocity, 8 double buffered link velocities
layout( binding = 2, r32f ) uniform restrict writeonly imageBuffer popul_buf[17];

// velocity and density write target, will be rendered as texture in next pass
layout( binding = 3, rgba16f ) uniform restrict writeonly image2D vel_rho_img;

// boundary and force definitions texture/array
//layout( binding = 1 ) uniform writeonly iimage2D imgCellType;


// population indices
// 6 2 5 //
//  \|/  //
// 3-0-1 //
//  /|\  //
// 7 4 8 //


// LBM constants
const float     t = 1.9;    // tau or omega representing viscosity
const float[9]  w = { 4.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/36, 1.0/36, 1.0/36, 1.0/36 };
const int[9]  inv = { 0, 3, 4, 1, 2, 7, 8, 5, 6 };

// Cell Type Attributes
//#define NOSLIP 1
//#define FORCE 2

// define global equivalent for gl_LocalInvocationIndex
#define UI gl_GlobalInvocationID.x

// U and I are also the index velocity population index
#define I int( UI )

#define X ( I % imageSize( vel_rho_img ).x )
#define Y ( I / imageSize( vel_rho_img ).x )
//#define Z ( I / ( imageSize( vel_rho_img ).x * imageSize( vel_rho_img ).y )



void main( void )  {

    // Init velocities and densities
    imageStore( vel_rho_img, ivec2( X, Y ), vec4( 0, 0, 0, 1 ));

    // init all distribution f(unctions) with equilibrium, p = population
    for( int p = 0; p < 9; ++p )  {
        imageStore( popul_buf[ p     ], I, vec4( w[ p ] ));
        //if( p > 0 ) imageStore( popul_buf[ p + 8 ], I, vec4( w[ p ] ));
    }
}