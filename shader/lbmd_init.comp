// --- COMP ---
#version 450

// Inject definition for:
//  cls(X/Y) = computeLocalSize divisions
//  div(X/Y) = divisions of the simulation grid
//  typ(X/Y) = divisions of the cell type grid (typ = div + 2)
// --- DEFINE ---

// spetialization constants for local work group size
layout( local_size_x_id = 0 ) in;
layout( local_size_y_id = 1 ) in;
layout( local_size_z_id = 2 ) in;
/*  */
// local work group defaults, when constants are not defined
layout( local_size_x = 256 ) in;
layout( local_size_y =   1 ) in;
layout( local_size_z =   1 ) in;

// populations 1 single buffered rest velocity, 8 double buffered link velocities
layout( binding = 2, r32f  ) uniform restrict writeonly imageBuffer popul_buf[17];

// velocity and density write target, will be rendered as texture in next pass
layout( binding = 3, rgba16f ) uniform restrict writeonly image2D vel_rho_img;

// boundary and force definitions texture/array
//layout( binding = 1 ) uniform writeonly iimage2D imgCellType;


// population indices
// 6 2 5 //
//  \|/  //
// 3-0-1 //
//  /|\  //
// 7 4 8 //


// LBM constants
const float     t = 1.9;    // tau or omega representing viscosity
const float[9]  w = { 4.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/36, 1.0/36, 1.0/36, 1.0/36 };
const int[9]  inv = { 0, 3, 4, 1, 2, 7, 8, 5, 6 };

// Cell Type Attributes
//#define NOSLIP 1
//#define FORCE 2

// indices for LBM data as well as velocity and density
//uint u = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
uint u = gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.x;




void main( void )  {

	// indices for 2D velocity and density image
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
	int  i = int( u );

    // Init velocities and densities
    imageStore( vel_rho_img, ivec2( x, y ), vec4( 1, 0, 0, 1 ));


    // init all distribution f(unctions) with equilibrium, p = population
    imageStore( popul_buf[ 0 ], i, vec4( w[ 0 ] ));
    for( int p = 1; p < 9; ++p )  {
        imageStore( popul_buf[ p     ], i, vec4( 0 ));
        imageStore( popul_buf[ p + 8 ], i, vec4( 0 ));

        if( x == gl_WorkGroupSize.x / 4 && y == gl_WorkGroupSize.x / 4 ) {
        	imageStore( popul_buf[ p     ], i, vec4( w[ p ] ));
        	imageStore( popul_buf[ p + 8 ], i, vec4( w[ p ] ));
        }
    }
}