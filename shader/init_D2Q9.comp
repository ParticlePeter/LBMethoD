// --- COMP ---
#version 450 core

// specialization constants for local work group size
layout( local_size_x_id = 0 ) in;
layout( local_size_y_id = 1 ) in;
layout( local_size_z_id = 2 ) in;

// local work group defaults, when constants are not defined
layout( local_size_x = 256 ) in;
layout( local_size_y =   1 ) in;
layout( local_size_z =   1 ) in;

// populations 1 single buffered rest velocity, 8 double buffered link velocities
layout( binding = 2, r32f  ) uniform restrict imageBuffer popul_buffer;

// velocity and density write target, will be rendered as texture in next pass
layout( binding = 3, rg32f /*rgba16f*/ ) uniform restrict writeonly image2DArray vel_rho_img;


// population indexes
// 6 2 5 //
//  \|/  //
// 3-0-1 //
//  /|\  //
// 7 4 8 //

// Directions:          R       E       N       W       S       NE      NW      SW      SE
const float[9] pw = {   4.0/9,  1.0/9,  1.0/9,  1.0/9,  1.0/9,  1.0/36, 1.0/36, 1.0/36, 1.0/36 };

// shortcut to imageSize, the Domain of the computation, same as Global Size
#define D ( gl_WorkGroupSize * gl_NumWorkGroups )

// define global equivalent for gl_LocalInvocationIndex
#define UI gl_GlobalInvocationID.x

// U and I are also the index velocity population index
#define NWG gl_NumWorkGroups
#define WGI gl_WorkGroupID
#define WGS gl_WorkGroupSize
#define GII gl_GlobalInvocationID
#define LII gl_LocalInvocationID
#define LI gl_LocalInvocationIndex
#define I int(( NWG.x * NWG.y * WGI.z + NWG.x * WGI.y + WGI.x ) * WGS.x * WGS.y * WGS.z + LI )

#define X ( I % D.x )
#define Y ( I / D.x )
#define Z ( I / ( D.x * D.y ))

// We cannot use these as they do not correspond to the X, Y, Z algorithm above and do not work correctly
// when a multi dimensional work group size is setup. In that case all one work group is consecutive in memory
// but we require first the whole domain in X laying consecutively
//#define X gl_GlobalInvocationID.x
//#define Y gl_GlobalInvocationID.y
//#define Z gl_GlobalInvocationID.z

// derived total count of nodes
int cell_count = int( NWG.x * NWG.y * NWG.z * WGS.x * WGS.y * WGS.z );


// main simulation function
void main( void ) {

    // Init velocities and densities
    imageStore( vel_rho_img, ivec3( X, Y, Z ), vec4( 0, 0, 0, 1 ));
    //imageStore( vel_rho_img, ivec3( X, Y, Z ), vec4( WGI, 1 ) / vec4( NWG - 1, 1 ));
    //imageStore( vel_rho_img, ivec3( X, Y, Z ), vec4( I / float( cell_count - 1 ), 0, 0, 1 ));

    // init all distribution f(unctions) with equilibrium, p = population
    for( int p = 0; p < 9; ++p )  {
        imageStore( popul_buffer, p * cell_count + I, vec4( pw[ p ] ));
        if( p > 0 ) imageStore( popul_buffer, ( p + 8 ) * cell_count + I, vec4( pw[ p ] ));
    }
}   // main